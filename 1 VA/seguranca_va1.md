<img src=header1VA.JPG>


Nome Completo: Allysson Guimarães dos Santos Silva

Questões retiradas do livro-texto da disciplina. 

**1. Para cada um dos seguintes recursos, determine um nível de impacto baixo, moderado ou alto à perda de confidencialidade, disponibilidade e integridade, respectivamente. Justifique suas respostas.** 

**(a) uma organização gerenciando informações públicas em seu servidor web.** 

Confidencialidade: Baixo

A perda de confidencialidade de informações públicas não seria um grande problema para a organização. As informações públicas são, por definição, informações que não são confidenciais. Se alguém obtivesse acesso a informações públicas, isso não teria um impacto significativo na organização.

Disponibilidade: Moderado

A perda de disponibilidade de informações públicas poderia ser um problema moderado para a organização. As informações públicas são importantes para que as pessoas possam acessar informações sobre a organização e seus produtos ou serviços. Se as informações públicas não estiverem disponíveis, isso poderia dificultar o acesso das pessoas às informações de que precisam.

Integridade: Moderado

A perda de integridade de informações públicas poderia ser um problema moderado para a organização. As informações públicas devem ser precisas e confiáveis. Se as informações públicas forem alteradas ou corrompidas, isso poderia levar as pessoas a tomar decisões com base em informações incorretas.

Portanto, o nível de impacto à perda de confidencialidade é baixo, à disponibilidade é moderado e à integridade também é moderado para uma organização que gerencia informações públicas em seu servidor  web.

**(b) uma organização de aplicação da lei gerindo informações de investigação extremamente sensíveis.** 

Confidencialidade: Alta

O impacto da perda de confidencialidade de informações de investigação extremamente sensíveis é alto. Isso ocorre porque essas informações podem ser usadas para prejudicar pessoas.

Disponibilidade: Alta

O impacto da perda de disponibilidade de informações de investigação extremamente sensíveis é alto. Isso ocorre porque essas informações podem ser necessárias para justiça

Integridade: Alta

A  perda de integridade de informações de investigação extremamente sensíveis é alto. Isso ocorre porque a perda de integridade pode levar a erros ou imprecisões nas informações.



**(c) uma organização financeira gerindo informações administrativas rotineiras (sem informações relacionadas à privacidade).** 

Confidencialidade: Moderado

O impacto da perda de confidencialidade de informações administrativas rotineiras é moderado. Isso ocorre porque essas informações não são sensíveis e não podem ser usadas para prejudicar pessoas, mas as perdas dessas informações pode causar problemas para a organização e seus clientes. Por exemplo, se as informações sobre uma transação financeira forem divulgadas, o cliente pode ser vítima de fraude.

Disponibilidade: Moderado

O impacto da perda de disponibilidade de informações administrativas rotineiras é moderado. Isso ocorre porque essas informações não são essenciais para o funcionamento da organização. No entanto, a perda de disponibilidade dessas informações pode causar problemas para a organização e seus clientes.

Integridade: Moderado

A perda de integridade de informações administrativas rotineiras pode levar a erros ou imprecisões nas informações. Isso pode causar problemas para a organização e seus clientes. Por exemplo, se as informações sobre uma transação financeira forem alteradas, o cliente pode ser cobrado por uma quantia incorreta.

**(d) um sistema de informação utilizado para grandes aquisições em uma organização voltada a contratações que contém dados sensíveis da fase de pré-solicitação e dados administrativos rotineiros. avalie o impacto de haver dois conjuntos de dados separadamente e o sistema de informação único.** 

Confidencialidade: Alta

O impacto da perda de confidencialidade de dados sensíveis é alto. Isso ocorre porque esses dados podem ser usados para prejudicar a organização ou seus parceiros.

Disponibilidade: Alta

O impacto da perda de disponibilidade de dados sensíveis da fase de pré-solicitação em um sistema de informação único é alto. Isso ocorre porque esses dados são essenciais para o processo de aquisição.

Integridade: Alta

O impacto da perda de integridade de dados sensíveis da fase de pré-solicitação em um sistema de informação único é alto. Isso ocorre porque esses dados são essenciais para o processo de aquisição.Por exemplo, a perda de integridade dessas informações pode levar a: decisões erradas, contratos inválidos e danos financeiros.

**(e) uma indústria de energia contém um sistema SCada (controle supervisório e aquisição de dados, do acrônimo em inglês para *supervisory control and data acquisition*) controlando a distribuição da energia elétrica para uma grande instalação militar. o sistema SCada contém tanto sensores de dados em tempo real quanto informações das rotinas administrativas. avalie o impacto de haver dois conjuntos de dados separadamente e o sistema de informação único.** 

Confidencialidade: Alta

Perda de confidencialidade: Os dados de sensores em tempo real são essenciais para o controle e a operação de uma instalação militar. Eles permitem que os operadores monitorem a rede elétrica e tomem medidas corretivas em caso de problemas. A perda de confidencialidade desses dados pode permitir que os inimigos obtenham informações sobre a operação da rede elétrica. Isso pode ser usado para planejar ataques ou sabotagens.

Disponibilidade: Alta

Perda de disponibilidade: Os dados de sensores em tempo real precisam estar disponíveis em tempo real para que os operadores possam tomar decisões rápidas e precisas. A perda de disponibilidade desses dados pode impedir que os operadores monitorem a rede elétrica. Isso pode levar a problemas de segurança, como quedas de energia ou falhas de equipamentos.

Integridade: Alta

Perda de integridade: Os dados de sensores em tempo real precisam ser precisos para que os operadores possam tomar decisões corretas. A perda de integridade desses dados pode levar a decisões erradas ou a ações incorretas. Isso pode aumentar o risco de acidentes ou incidentes.



**2. Responda, explique com exemplos, as questões abaixo:** 

**(a) Quais são os elementos essenciais de uma cifra simétrica? Explique-as.** 

Os elementos essenciais de uma cifra simétrica são:

Algoritmo de criptografia: é um conjunto de regras que transforma o texto claro em texto cifrado.

Chave secreta: é uma sequência de bits que é usada para realizar o processo de criptografia e descriptografia.

**(b) Quais são as duas funções básicas usadas nos algoritmos de encriptação? Explique-as.** 

Funções de Hash:

Uma função de hash transforma dados de comprimento variável em um valor de tamanho fixo, geralmente uma sequência de caracteres alfanuméricos chamada de "hash". A ideia fundamental é produzir uma representação única e "irreversível" dos dados de entrada.

Boas funções de hash devem ter propriedades como resistência à colisão (é difícil encontrar dois conjuntos de dados diferentes que produzam o mesmo hash), avalanche (pequenas mudanças nos dados de entrada devem causar grandes mudanças no hash) e resistência a ataques de pré-imagem.

As funções de hash são amplamente utilizadas para verificar a integridade dos dados, armazenar senhas de forma segura (usando técnicas como salting), gerar chaves de verificação de integridade (HMAC), e em estruturas de dados como tabelas de dispersão.


Funções de Cifra:

As funções de cifra são responsáveis por transformar dados (texto simples) em um formato cifrado (texto cifrado), usando uma chave. Existem cifras simétricas, onde a mesma chave é usada para criptografar e descriptografar, e cifras assimétricas, onde pares de chaves (pública e privada) são utilizados.

As cifras simétricas incluem cifras de bloco (que operam em blocos fixos de dados) e cifras de fluxo (que operam em bits individuais ou em pequenos conjuntos de bits de cada vez).

As funções de cifra são essenciais para garantir a confidencialidade dos dados. Elas são amplamente utilizadas em comunicações seguras pela internet, proteção de dados armazenados e em diversos protocolos de segurança.

**(c) Quantas chaves são necessárias para duas pessoas se comunicarem por meio de uma cifra? Explique-as, demonstrando, você pode se utilizar de gráficos ou desenhos.** 

Para duas pessoas se comunicarem por meio de uma cifra simétrica, é necessária apenas uma chave. Essa chave deve ser compartilhada entre as duas partes, de forma que elas possam usar a mesma chave para criptografar e descriptografar os dados.

Exemplo:

Alice e Bob desejam se comunicar por meio de uma cifra simétrica. Eles escolhem uma chave secreta, que pode ser uma sequência de números aleatórios, uma frase secreta ou uma combinação de números, letras e símbolos.

Alice criptografa uma mensagem usando a chave secreta. A mensagem cifrada é enviada para Bob. Bob descriptografa a mensagem usando a mesma chave secreta. Ele recebe a mensagem original.É importante notar que a chave secreta deve ser mantida em segredo, pois caso ela seja descoberta por terceiros, eles poderão decifrar as mensagens criptografadas.



**(d) Quais são as duas técnicas gerais para atacar uma cifra? Explique-as.** 

Criptoanálise: é o estudo de métodos para quebrar cifras.

Ataque por força bruta: é um método de ataque que tenta todas as possíveis combinações de chaves até encontrar a correta.

**(e) Defina resumidamente a cifra de César; a cifra de Hill; a cifra de Feistel (por que é impor tante estudá-la?); e, a diferença entre DES, Rijndael e AES.** 

Cifra de César

A cifra de César é uma cifra de substituição simples que desloca cada letra do texto claro uma posição para a frente ou para trás no alfabeto. Por exemplo, se a chave for 3, a letra "A" será criptografada como "D", a letra "B" como "E", e assim por diante.

Cifra de Hill

A cifra de Hill é uma cifra de substituição polinomial que usa uma matriz quadrada para substituir cada letra do texto claro por outra letra. A matriz de substituição é definida pela chave da cifra.

Cifra de Feistel

A cifra de Feistel é uma estrutura de cifra que divide o texto claro em blocos de tamanho fixo e, em seguida, aplica uma função de rodada a cada bloco, usando uma chave de tamanho variável. A função de rodada é geralmente uma função não-linear que torna difícil para os atacantes quebrar a cifra.

A importância da cifra de Feistel

A cifra de Feistel é importante porque é a base de muitas cifras modernas, incluindo o DES, o Rijndael e o AES. A estrutura de Feistel torna as cifras mais seguras do que as cifras de substituição simples, pois torna mais difícil para os atacantes encontrar padrões no texto cifrado.

Diferença entre DES, Rijndael e AES

O DES (Data Encryption Standard) é uma cifra de bloco simétrica que foi desenvolvida pela IBM e adotada pelo governo dos EUA como padrão em 1977. O DES usa uma chave de 56 bits, o que o torna vulnerável a ataques por força bruta modernos.

O Rijndael é uma cifra de bloco simétrica que foi desenvolvida pela Bélgica e adotada pelo governo dos EUA como padrão em 2001. O Rijndael pode usar chaves de tamanhos variáveis, de 128, 192 ou 256 bits. O AES (Advanced Encryption Standard) é uma variante do Rijndael que usa uma chave de 128 bits.

A principal diferença entre o DES e o AES é o tamanho da chave. O AES usa uma chave maior, o que o torna mais seguro do que o DES. O Rijndael pode usar chaves de tamanhos maiores, mas o AES é o mais amplamente adotado.

**3. Quando o barco de patrulha norte-americano PT-109, sob o comando do tenente John f. Ken nedy, foi afundado por um destróier japonês, uma mensagem foi recebida na estação sem fio australiana em código playfair:** 

**KXJEY UREBE ZWEHE WRYTU HEYFS**

**KREHE GOYFI WTTTU OLKSY CAJPO** 

**BOTEI ZONTX BYBNT GONEY CUZWR** 

**GDSON SXBOU YWRHE BAAHY USEDQ** 



**a chave usada foi royal new zealand navy. decripte a mensagem. traduza TT para tt.** 

<https://www.online.crypto-it.net/eng/playfair.html> 

PT BOAT ONE OWE NINE LOST IN ACTION IN BLACKESXSX STRAIT TWO MILES SW MERESU COCE X CREW OF TWELVE X REQUEST ANY INFORMATION X



**4. Crie uma aplicação que possa encriptar e decriptar usando uma cifra de Hill 2 *×* 2.** 

[**Código**](https://cocalc.com/projects/88241b82-0533-415a-82fe-90318b249e95/files/1VA.ipynb#id=0d10db)

**ptbr\_alphabet = "abcdefghijklmnopqrstuvwxyz "**

**def char\_to\_num(c):**

`    `**return ptbr\_alphabet.index(c.lower()) + 1**

**def num\_to\_char(x):**

`    `**return ptbr\_alphabet[x % 27]**

**def HillEncrypt(M, plainText):**

`    `**txt\_encrip = ""**
**


`    `**if(len(plainText) % 2 != 0):**

`        `**plainText += " "**
**


`    `**for i in range(0, (len(plainText)- 1), 2):**

`        `**#transformando os caracteres em numeros**

`        `**x = char\_to\_num(plainText[i])**

`        `**y = char\_to\_num(plainText[i+1])**
**


`        `**#criando segunda matriz**

`        `**M2 = matrix([[x],[y]])**
**


`        `**mensagem\_codificada = M \* M2**

**        

`        `**txt\_encrip += str(num\_to\_char(mensagem\_codificada[0][0] - 1))**

`        `**txt\_encrip += str(num\_to\_char(mensagem\_codificada[1][0] - 1))**

`    `**print(txt\_encrip)**

`    `**return txt\_encrip**

**def HillDecrypt(M, plainText):**

`    `**txt\_decrip = ""**

`    `**inverse = inverseMatrix(M)**
**


`    `**for i in range(0, (len(plainText)- 1), 2):**

`        `**#transformando os caracteres em numeros**

`        `**x = char\_to\_num(plainText[i])**

`        `**y = char\_to\_num(plainText[i+1])**
**


`        `**#criando segunda matriz**

`        `**M2 = matrix([[x],[y]])**
**


`        `**mensagem\_codificada = inverse \* M2**
**


`        `**txt\_decrip += str(num\_to\_char(mensagem\_codificada[0][0] - 1))**

`        `**txt\_decrip += str(num\_to\_char(mensagem\_codificada[1][0] - 1))**
**


`    `**print(txt\_decrip)**   

`    `**return txt\_decrip**

**key = matrix([[2, 1],[-6, 4]]);=**

**txt\_encript = HillEncrypt(key,"testando cifra de hill")**

**txt\_decript = HillDecrypt(key,txt\_encript)**





**5. Responda, resumidamente, as questões a seguir:** 

**(a) Qual é a diferença entre uma cifra de bloco e uma cifra de fluxo?** 

Uma cifra de bloco criptografa dados em blocos fixos, enquanto uma cifra de fluxo opera em bits individuais.

**(b) O que é uma cifra de produto?** 

É a combinação de duas ou mais cifras independentes para aumentar a segurança.

**(c) Qual é a diferença entre difusão e confusão? Explique.** 

Difusão consiste em espalhar e distribuir a influência de um dado de entrada por todo o resultado da cifragem.

Confusão, por outro lado, envolve tornar a relação entre a chave e o texto cifrado o mais complexa possível

**(d) Quais parâmetros e escolhas de projeto determinam o algoritmo real de uma cifra de Feistel?** 

O número de rodadas, tamanho dos blocos de dados, chave, dentre outros.

**(e) Explique o efeito avalanche.** 

Consiste em realizar uma pequena alteração nos dados de entrada ou na chave que resulta em mudanças significativas nos dados de saída.



<b>6. Encontre o inverso multiplicativo de cada elemento diferente de zero em <i>Z</i><sub>5</sub></b> 

[**Código**](https://cocalc.com/projects/88241b82-0533-415a-82fe-90318b249e95/files/1VA.ipynb#id=0d10db)

**def encontrar\_inversos\_multiplicativos(modulo):**

`    `**inversos = {}**

`    `**for elemento in range(1, modulo):**

`        `**for candidato in range(1, modulo):**

`            `**if (elemento \* candidato) % modulo == 1:**

`                `**inversos[elemento] = candidato**

`                `**break**

`    `**return inversos**

**# Modulo para Z5**

**modulo\_z5 = 5**

**# Encontrar inversos multiplicativos em Z5**

**inversos\_z5 = encontrar\_inversos\_multiplicativos(modulo\_z5)**

**# Exibir resultados**

**print("Elemento | Inverso Multiplicativo")**

**print("-" \* 30)**

**for elemento, inverso in inversos\_z5.items():**

`    `**print(f"    {elemento}          |          {inverso}")**

**Elemento | Inverso Multiplicativo**

**------------------------------**

`    `**1          |          1**

`    `**2          |          3**

`    `**3          |          2**

`    `**4          |          4**




<b>7. Para a aritmética de polinômios com coeficientes em <i>Z</i><sub>10</sub>, realize os seguintes cálculos:</b> 

<b>1. (7<i>x</i> + 2) <i>−</i> (<i>x</i><sup>2</sup> + 5)</b> 

<b>2. (6<i>x</i><sup>2</sup> + <i>x</i> + 3) <i>×</i> (5<i>x</i><sup>2</sup> + 2)</b> 

[**Código**](https://cocalc.com/projects/88241b82-0533-415a-82fe-90318b249e95/files/1VA.ipynb#id=0d10db)

**# Define the symbolic variable x**

**var('x')**

**# Define the given expression**

**expression = expand((7\*x + 2) - (x^2 + 5))**

**# Print the result**

**print(expression)**

**-x^2 + 7\*x - 3**

**# Define the symbolic variable x**

**var('x')**

**#(6x^2 + x + 3) × (5x^2 + 2)**

**# Define the given expression**

**expression = expand((6\*x^2 + x + 3) \* (5\*x^2 + 2))**

**# Print the result**

**print(expression)**

**30\*x^4 + 5\*x^3 + 27\*x^2 + 2\*x + 6**

**8. Use a chave 1010 0111 0011 1011 para encriptar o texto claro "ok"conforme expresso em ASCII, ou seja, 0110 1111 0110 1011. Os projetistas do S-AES obtiveram o texto cifrado 0000 0111 0011 1000. E você?**  

**11000011**

[**Código**](https://cocalc.com/projects/88241b82-0533-415a-82fe-90318b249e95/files/1VA.ipynb#id=0d10db)

**# Define a função para encriptar o texto claro usando a chave**

**def encriptar(chave, texto\_claro):**

`    `**# Converter o texto claro para binário**

`    `**texto\_binario = bin(texto\_claro)[2:].zfill(16)**
**


`    `**# Verificar se o texto binário tem o tamanho correto**

`    `**if len(texto\_binario) != 16:**

`        `**raise ValueError("O texto claro deve ter 16 bits")**
**


`    `**# Converter a chave para binário**

`    `**chave\_binario = bin(chave)[2:].zfill(16)**
**


`    `**# Realizar a permutação inicial**

`    `**p1 = [2, 6, 3, 1, 4, 8, 5, 7]**

`    `**texto\_p1 = ''.join(texto\_binario[i-1] for i in p1)**
**


`    `**# Aplicar a operação XOR entre o texto e a chave**

`    `**texto\_xor = bin(int(texto\_p1, 2) ^ int(chave\_binario, 2))[2:].zfill(8)**
**


`    `**# Realizar a permutação final**

`    `**p2 = [4, 1, 3, 5, 7, 2, 8, 6]**

`    `**texto\_cifrado = ''.join(texto\_xor[i-1] for i in p2)**
**


`    `**return texto\_cifrado**

**# Utilizar a chave e o texto fornecidos para obter o texto cifrado**

**chave = 0b1010011100111011**

**texto\_claro = 0b110111101101011**


**texto\_cifrado\_esperado = "0000011100111000"**

**texto\_cifrado\_obtido = encriptar(chave, texto\_claro)**

**# Verificar se o texto cifrado obtido coincide com o texto cifrado esperado**

**texto\_cifrado\_esperado == texto\_cifrado\_obtido**

**print(texto\_cifrado\_obtido)**



**9. Compare AES com DES. Para cada um dos seguintes elementos do DES, indique o elemento comparável no AES ou explique por que ele não é necessário no AES.** 

**(a) XOR do material da subchave com a entrada da função f.** 

O AES também utiliza uma operação semelhante, AddRoundKey, que envolve um XOR entre o array de estado e a subchave da rodada. No entanto, o processo é mais direto no AES, pois cada byte do estado é XOR diretamente com o byte correspondente da subchave.

**(b) XOR da saída da função f com a metade esquerda do bloco.** 

Este passo não é diretamente comparável no AES. No AES, a difusão dos bits é alcançada por meio de operações como SubBytes, ShiftRows e MixColumns, e não há um passo específico equivalente ao XOR mencionado.

**(c) função f.** 

SubBytes e a operação de MixColumns no AES desempenham funções semelhantes à função f do DES. Elas proporcionam confusão e difusão necessárias para a segurança do algoritmo.

**(d) permutação P.** 

O AES não possui uma operação específica equivalente à permutação P do DES. A difusão no AES é alcançada de maneira diferente, principalmente por meio da operação ShiftRows e MixColumns.

**(e) troca de metades do bloco.** 

Esta operação não é necessária no AES, pois o AES utiliza uma estrutura de blocos uniforme e opera diretamente em blocos de dados de tamanho fixo (128 bits). A troca de metades do bloco no DES é usada para misturar os dados entre as duas metades, o que não é uma consideração no AES.





**10. Calcule a saída da transformação MixColumns para a seguinte sequência de bytes de entrada "67 89 AB CD". Aplique a transformação InvMixColumns ao resultado obtido para verificar seus cálculos. Altere o primeiro byte da entrada de "67"para "77", realize a transformação MixColumns novamente para a nova entrada e determine quantos bits mudaram na saída.** 

**Nota: você pode realizar todos os cálculos à mão ou escrever um programa que dê suporte a eles. Se escolher escrever um programa, ele deverá ser feito inteiramente por você; nesta tarefa, não use bibliotecas ou código fonte de domínio público (você pode se guiar pelos exemplos Sage disponibilizados).** 

[**Código**](https://cocalc.com/projects/88241b82-0533-415a-82fe-90318b249e95/files/1VA.ipynb#id=0d10db)

**import numpy as np**

**def mix\_columns(state):**

`    `**# Matriz de mistura para MixColumns**

`    `**mix\_matrix = np.array([**

`        `**[0x02, 0x03, 0x01, 0x01],**

`        `**[0x01, 0x02, 0x03, 0x01],**

`        `**[0x01, 0x01, 0x02, 0x03],**

`        `**[0x03, 0x01, 0x01, 0x02]**

`    `**], dtype=np.uint8)**

`    `**result = np.zeros\_like(state)**

`    `**for i in range(4):**

`        `**for j in range(4):**

`            `**result[i] ^= mix\_matrix[i, j] \* state[j]**

`    `**return result**

**def inv\_mix\_columns(state):**

`    `**# Matriz de mistura inversa para InvMixColumns**

`    `**inv\_mix\_matrix = np.array([**

`        `**[0x0e, 0x0b, 0x0d, 0x09],**

`        `**[0x09, 0x0e, 0x0b, 0x0d],**

`        `**[0x0d, 0x09, 0x0e, 0x0b],**

`        `**[0x0b, 0x0d, 0x09, 0x0e]**

`    `**], dtype=np.uint8)**

`    `**result = np.zeros\_like(state)**

`    `**for i in range(4):**

`        `**for j in range(4):**

`            `**result[i] ^= inv\_mix\_matrix[i, j] \* state[j]**

`    `**return result**

**def print\_bytes(matrix):**

`    `**for row in matrix:**

`        `**for val in row:**

`            `**print(f"{val:02X}", end=" ")**

`        `**print()**

**# entrada**

**input\_bytes = np.array([0x67, 0x89, 0xAB, 0xCD], dtype=np.uint8).reshape(4, 1)**

**# Passo 1: MixColumns**

**mix\_columns\_result = mix\_columns(input\_bytes)**

**print("MixColumns:")**

**print\_bytes(mix\_columns\_result)**

**print()**

**# Passo 2: InvMixColumns**

**inv\_mix\_columns\_result = inv\_mix\_columns(mix\_columns\_result)**

**print("InvMixColumns:")**

**print\_bytes(inv\_mix\_columns\_result)**

**print()**

**# Altere o primeiro byte para 0x77**

**input\_bytes[0] = 0x77**

**# Passo 3: MixColumns novamente**

**mix\_columns\_result\_updated = mix\_columns(input\_bytes)**

**print("MixColumns (Atualizado):")**

**print\_bytes(mix\_columns\_result\_updated)**

**print()**

**# Determinar quantos bits mudaram na saída**

**bit\_diff\_count = np.sum(np.bitwise\_xor(mix\_columns\_result, mix\_columns\_result\_updated))**

**print(f"Quantidade de bits diferentes na saída: {bit\_diff\_count}")**

**MixColumns:**

**33** 

**B9** 

**DF** 

**8D** 

**InvMixColumns:**

**9F** 

**69** 

**2B** 

**35** 

**MixColumns (Atualizado):**

**13** 

**A9** 

**CF** 

**DD** 

**Quantidade de bits diferentes na saída: 5**

**11. (2 pontos-extra) Crie um software que possa encriptar e decriptar usando S-AES. Dados de teste: um texto claro binário de 0110 1111 0110 1011 encriptado com uma chave binária de 1010 0111 0011 1011 deverá dar o texto cifrado binário 0000 0111 0011 1000. A decriptação deverá funcionar da mesma forma.** 
